########Implementation of the first functions: Euclidean, Manhattan, Cosine and Canberra

mydistfun<- function(element1,element2,metricf){
  # this function returns the distace between the element1 and element2
  # according to the metricf
  
  dimensions=length(element1)
  sqd<-matrix(,dimensions,1)
  
  if (metricf=="Euclidean"){
    
    #euclidean
    for(i in seq(along=element1)){
      
      sqd[i]<-(element1[i]-element2[i])^2
    }
    dist<-sqrt(colSums(sqd))
    
  }
  if (metricf=="Manhattan"){
    
    #manhattan
    for(i in seq(along=element1)){
      
      sqd[i]<-(element1[i]-element2[i])
    }
    dist<-abs(colSums(sqd))
    
  }
  
  #implement cosine distance
  if (metricf=="Cosine"){
    
    #cosine
    dist= sum(element1 * element2) / (sqrt(sum(element1^2)) * sqrt(sum(element2^2)))
    
  }
  
  if (metricf=="Canberra"){
    
    #Canberra
    for(i in seq(along=element1)){
      
      sqd[i]<-(element1[i]-element2[i])/(element1[i]+element2[i])
    }
    dist<-abs(colSums(sqd))
    
  }
  
  return(dist)
}

#Initial dataset and sample, generated by normal distribution, 2 vectors
library(lsa)
n= 100
x1= rnorm(n)
x2= rnorm(n)

mydistfun(x1,x2,"Euclidean")
mydistfun(x1,x2, "Cosine")
mydistfun(x1,x2, "Manhattan")
mydistfun(x1,x2, "Canberra")

#We compared our solution vs the default cosine function
cosine(x1,x2)

################  Implementation of the minkowski distance
dist_mink= function(element1, element2, p){
  dist= as.integer(0)
  sqd= as.numeric()
  # When p= 0, we calculate the Chebyshev distance
  if(p==0){
    for (i in seq(along=element1)) {
      sqd[i]<-(element1[i]-element2[i])
    }
    dist=max(sqd)
  }
  
  else{# otherwise, we calculate the minkowski distance
    for (i in 1:length(element1)) {
      di= as.integer(abs(element1[i] - element2[i]) ^ p)
      dist= sum(di,dist)
    }
    dist = dist ^ (1 / p)
  }
  
  return(dist)
}

p= 2
dist_mink(x1,x2,p)

###########Implementation of the Mahalanobis distance
n=100 #Length of the vectors
x1= rnorm(n)
x2=rnorm(n)
df= cbind(x1,x2)

dist_mah= function(df){
  m_cov= cov(df)
  cov_inv= solve(m_cov)
  center_point=as.matrix(colMeans(df))
  output=numeric(length = nrow(df))
  
  for (i in 1:(nrow(df))) {
    ef= df[i,]
    a1=ef-center_point
    a2=t(a1)%*%cov_inv
    af=a2%*%a1
    output[i]=af
  }
  
  return(output)
}
dist_mah(df)

##We test our mahalanobis function vs the default R function
m= mahalanobis(df, colMeans(df), cov(df))
m
error=mean(dist_mah(df)-m)
error

error=mean(dist_mah(x1,x2)-m)
